import time
from typing import Any, TypedDict

from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import END, StateGraph

from chatbot.config.chatbot_config import config


class ConversationState(TypedDict):
    current_question_id: int
    questions: list[dict[str, Any]]
    user_answers: dict[int, str]
    validation_results: dict[int, dict[str, Any]]
    conversation_history: list[dict[str, Any]]
    current_status: str
    error_message: str
    next_question: dict[str, Any]
    is_completed: bool
    retry_count: dict[int, int]


class ConversationGraphAgent:
    """LangGraphÎ•º ÏÇ¨Ïö©Ìïú ÎåÄÌôî Í∑∏ÎûòÌîÑ ÏóêÏù¥Ï†ÑÌä∏"""

    def __init__(self) -> None:
        self.questions = config.body_diagnosis_config.questions
        self.graph = self._build_graph()
        self.memory = MemorySaver()

    def _build_graph(self) -> StateGraph:
        """ÎåÄÌôî Í∑∏ÎûòÌîÑ Íµ¨ÏÑ±"""
        workflow = StateGraph(ConversationState)

        # ÎÖ∏Îìú Ï∂îÍ∞Ä
        workflow.add_node("ask_question", self._ask_question)
        workflow.add_node("validate_answer", self._validate_answer)
        workflow.add_node("handle_error", self._handle_error)
        workflow.add_node("save_answer", self._save_answer)
        workflow.add_node("check_completion", self._check_completion)

        # Ïó£ÏßÄ Ïó∞Í≤∞
        workflow.set_entry_point("ask_question")

        workflow.add_edge("ask_question", "validate_answer")
        workflow.add_conditional_edges(
            "validate_answer",
            self._route_after_validation,
            {"valid": "save_answer", "invalid": "handle_error", "completed": END},
        )
        workflow.add_edge("handle_error", "ask_question")
        workflow.add_edge("save_answer", "check_completion")
        workflow.add_conditional_edges(
            "check_completion",
            self._route_after_save,
            {"continue": "ask_question", "completed": END},
        )

        return workflow.compile(checkpointer=self.memory)

    def _ask_question(self, state: ConversationState) -> ConversationState:
        """ÏßàÎ¨∏ Ï†úÏãú"""
        current_id = state["current_question_id"]
        question = next((q for q in state["questions"] if q["id"] == current_id), None)

        if question:
            state["next_question"] = question
            state["current_status"] = "asking"
            state["error_message"] = ""
        else:
            state["is_completed"] = True
            state["current_status"] = "completed"

        return state

    def _validate_answer(self, state: ConversationState) -> ConversationState:
        """ÎãµÎ≥Ä Í≤ÄÏ¶ù"""
        current_id = state["current_question_id"]
        question = next((q for q in state["questions"] if q["id"] == current_id), None)

        if not question:
            state["current_status"] = "completed"
            return state

        # ÏÇ¨Ïö©Ïûê ÎãµÎ≥Ä Í∞ÄÏ†∏Ïò§Í∏∞ (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Ïô∏Î∂ÄÏóêÏÑú Ï£ºÏûÖ)
        user_answer = state.get("user_answers", {}).get(current_id, "")

        if not user_answer:
            state["current_status"] = "waiting_answer"
            return state

        # Í≤ÄÏ¶ù ÏàòÌñâ
        validation_result = self._perform_validation(user_answer, question["validation"])

        if validation_result["valid"]:
            state["current_status"] = "valid"
            state["validation_results"][current_id] = validation_result
        else:
            state["current_status"] = "invalid"
            state["error_message"] = validation_result["error_message"]

        return state

    def _perform_validation(self, answer: str, rules: dict[str, Any]) -> dict[str, Any]:
        """ÎãµÎ≥Ä Í≤ÄÏ¶ù Î°úÏßÅ"""
        validation_type = rules["type"]

        if validation_type == "numeric_range":
            try:
                value = float(answer)
                min_val = rules["min"]
                max_val = rules["max"]

                if min_val <= value <= max_val:
                    return {
                        "valid": True,
                        "normalized_value": value,
                        "error_message": "",
                    }
                else:
                    return {"valid": False, "error_message": rules["error_message"]}
            except ValueError:
                return {"valid": False, "error_message": "Ïà´ÏûêÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."}

        elif validation_type == "choice":
            if answer in rules["options"]:
                return {"valid": True, "normalized_value": answer, "error_message": ""}
            else:
                return {"valid": False, "error_message": rules["error_message"]}

        return {"valid": True, "normalized_value": answer, "error_message": ""}

    def _generate_help_message(self, question: dict[str, Any], user_answer: str) -> str:
        """ÏÇ¨Ïö©Ïûê ÎãµÎ≥ÄÏùÑ Î∂ÑÏÑùÌïòÏó¨ ÎèÑÏõÄÎßê ÏÉùÏÑ±"""
        validation_type = question["validation"]["type"]
        retry_count = question.get("retry_count", 0)

        # Í∏∞Î≥∏ ÎèÑÏõÄÎßê
        base_help = question.get("help_text", "")

        if validation_type == "numeric_range":
            min_val = question["validation"]["min"]
            max_val = question["validation"]["max"]

            if retry_count == 1:
                return f"{base_help}\nüí° ÌûåÌä∏: {min_val}ÏóêÏÑú {max_val} ÏÇ¨Ïù¥Ïùò Ïà´ÏûêÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."
            elif retry_count == 2:
                return f"{base_help}\nüí° Íµ¨Ï≤¥Ï†Å ÏòàÏãú: {min_val + (max_val - min_val) // 2}ÏôÄ Í∞ôÏùÄ Ïà´ÏûêÎ•º ÏûÖÎ†•Ìï¥Î≥¥ÏÑ∏Ïöî."
            else:
                return f"{base_help}\nüí° ÏûêÏÑ∏Ìïú ÏÑ§Î™Ö: {question['question']}Ïóê ÎåÄÌïú ÎãµÎ≥ÄÏùÄ {min_val}ÏóêÏÑú {max_val} ÏÇ¨Ïù¥Ïùò Ïà´ÏûêÏó¨Ïïº Ìï©ÎãàÎã§."

        elif validation_type == "choice":
            options = question["validation"]["options"]

            if retry_count == 1:
                return f"{base_help}\nüí° ÌûåÌä∏: Îã§Ïùå Ï§ëÏóêÏÑú ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî: {', '.join(options)}"
            elif retry_count == 2:
                return f"{base_help}\nüí° Íµ¨Ï≤¥Ï†Å ÏòàÏãú: '{options[0]}' ÎòêÎäî '{options[1]}' Ï§ë ÌïòÎÇòÎ•º ÏûÖÎ†•Ìï¥Î≥¥ÏÑ∏Ïöî."
            else:
                return f"{base_help}\nüí° ÏûêÏÑ∏Ìïú ÏÑ§Î™Ö: Ï†ïÌôïÌûà '{' ÎòêÎäî '.join(options)}' Ï§ë ÌïòÎÇòÎ•º ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§."

        # ÏùºÎ∞òÏ†ÅÏù∏ Í≤ΩÏö∞
        if retry_count == 1:
            return f"{base_help}\nüí° ÌûåÌä∏: ÏßàÎ¨∏ÏùÑ Îã§Ïãú Ìïú Î≤à ÏùΩÏñ¥Î≥¥ÏÑ∏Ïöî."
        elif retry_count == 2:
            return f"{base_help}\nüí° Íµ¨Ï≤¥Ï†Å ÏòàÏãú: {base_help}Ïóê ÎÇòÏôÄÏûàÎäî ÌòïÏãùÏúºÎ°ú ÎãµÎ≥ÄÌï¥Î≥¥ÏÑ∏Ïöî."
        else:
            return f"{base_help}\nüí° ÏûêÏÑ∏Ìïú ÏÑ§Î™Ö: {question['question']}Ïóê ÎåÄÌïú ÎãµÎ≥ÄÏùÑ Ï†ïÌôïÌûà ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."

    def _handle_error(self, state: ConversationState) -> ConversationState:
        """ÏóêÎü¨ Ï≤òÎ¶¨ Î∞è Ïû¨ÏßàÎ¨∏ (ÎèÑÏõÄÎßê Ìè¨Ìï®)"""
        current_id = state["current_question_id"]
        question = next((q for q in state["questions"] if q["id"] == current_id), None)

        # ÏóêÎü¨ Î∂ÑÏÑù Î∞è ÎèÑÏõÄÎßê ÏÉùÏÑ±
        help_message = self._generate_help_message(
            question, state.get("user_answers", {}).get(current_id, "")
        )

        # ÏßàÎ¨∏Ïóê ÎèÑÏõÄÎßê Ï∂îÍ∞Ä
        enhanced_question = question.copy()
        enhanced_question["help_message"] = help_message
        enhanced_question["retry_count"] = state.get("retry_count", {}).get(current_id, 0) + 1

        # Ïû¨ÏãúÎèÑ ÌöüÏàò ÏóÖÎç∞Ïù¥Ìä∏
        if "retry_count" not in state:
            state["retry_count"] = {}
        state["retry_count"][current_id] = enhanced_question["retry_count"]

        # ÏóêÎü¨ Î©îÏãúÏßÄÏôÄ Ìï®Íªò Í∞ôÏùÄ ÏßàÎ¨∏ Îã§Ïãú Ï†úÏãú
        state["next_question"] = enhanced_question
        state["current_status"] = "retry"

        # ÎåÄÌôî ÌûàÏä§ÌÜ†Î¶¨Ïóê ÏóêÎü¨ Í∏∞Î°ù
        state["conversation_history"].append(
            {
                "type": "error",
                "question_id": current_id,
                "error": state["error_message"],
                "help_message": help_message,
                "retry_count": enhanced_question["retry_count"],
                "timestamp": time.time(),
            }
        )

        return state

    def _save_answer(self, state: ConversationState) -> ConversationState:
        """Ïú†Ìö®Ìïú ÎãµÎ≥Ä Ï†ÄÏû•"""
        current_id = state["current_question_id"]
        validation_result = state["validation_results"][current_id]

        # ÎãµÎ≥Ä Ï†ÄÏû•
        state["user_answers"][current_id] = validation_result["normalized_value"]

        # ÎåÄÌôî ÌûàÏä§ÌÜ†Î¶¨Ïóê ÏÑ±Í≥µ Í∏∞Î°ù
        state["conversation_history"].append(
            {
                "type": "success",
                "question_id": current_id,
                "answer": validation_result["normalized_value"],
                "timestamp": time.time(),
            }
        )

        return state

    def _check_completion(self, state: ConversationState) -> ConversationState:
        """ÏôÑÎ£å Ïó¨Î∂Ä ÌôïÏù∏"""
        current_id = state["current_question_id"]

        if current_id >= len(state["questions"]):
            state["is_completed"] = True
            state["current_status"] = "completed"
            return state

        # Îã§Ïùå ÏßàÎ¨∏ÏúºÎ°ú Ïù¥Îèô
        state["current_question_id"] = current_id + 1
        state["current_status"] = "continue"

        return state

    def _route_after_validation(self, state: ConversationState) -> str:
        """Í≤ÄÏ¶ù ÌõÑ ÎùºÏö∞ÌåÖ"""
        if state["current_status"] == "completed":
            return "completed"
        elif state["current_status"] == "valid":
            return "valid"
        else:
            return "invalid"

    def _route_after_save(self, state: ConversationState) -> str:
        """Ï†ÄÏû• ÌõÑ ÎùºÏö∞ÌåÖ"""
        if state["is_completed"]:
            return "completed"
        else:
            return "continue"

    def start_conversation(self, config: dict[str, Any] = None) -> ConversationState:
        """ÎåÄÌôî ÏãúÏûë"""
        initial_state = ConversationState(
            current_question_id=1,
            questions=self.questions,
            user_answers={},
            validation_results={},
            conversation_history=[],
            current_status="starting",
            error_message="",
            next_question={},
            is_completed=False,
            retry_count={},
        )

        if config:
            initial_state.update(config)

        return initial_state

    def submit_answer(self, state: ConversationState, answer: str) -> ConversationState:
        """ÎãµÎ≥Ä Ï†úÏ∂ú"""
        current_id = state["current_question_id"]
        state["user_answers"][current_id] = answer

        # Í∑∏ÎûòÌîÑ Ïã§Ìñâ
        result = self.graph.invoke(state)
        return result

    def get_current_status(self, state: ConversationState) -> dict[str, Any]:
        """ÌòÑÏû¨ ÏÉÅÌÉú Î∞òÌôò"""
        return {
            "current_question_id": state["current_question_id"],
            "total_questions": len(state["questions"]),
            "progress": f"{state['current_question_id']}/{len(state['questions'])}",
            "current_status": state["current_status"],
            "next_question": state.get("next_question", {}),
            "error_message": state.get("error_message", ""),
            "is_completed": state["is_completed"],
            "answers": state["user_answers"],
        }
